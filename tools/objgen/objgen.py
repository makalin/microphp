#!/usr/bin/env python3
"""
micro-PHP Object Generator (objgen)

This tool converts .mbc bytecode files into C source code
that can be embedded in firmware projects.
"""

import sys
import struct
import argparse
from pathlib import Path

# MBC file format constants
MBC_MAGIC = b'MBC\0'
MBC_VERSION = 1

def read_mbc_header(file):
    """Read and validate MBC file header."""
    magic = file.read(4)
    if magic != MBC_MAGIC:
        raise ValueError(f"Invalid MBC magic: {magic}")
    
    version = struct.unpack('<I', file.read(4))[0]
    if version != MBC_VERSION:
        raise ValueError(f"Unsupported MBC version: {version}")
    
    constant_count = struct.unpack('<I', file.read(4))[0]
    function_count = struct.unpack('<I', file.read(4))[0]
    main_offset = struct.unpack('<I', file.read(4))[0]
    
    return {
        'version': version,
        'constant_count': constant_count,
        'function_count': function_count,
        'main_offset': main_offset
    }

def read_zval(file):
    """Read a zval from the file."""
    zval_type = struct.unpack('<B', file.read(1))[0]
    
    if zval_type == 1:  # BOOL
        value = struct.unpack('<B', file.read(1))[0] != 0
        return f"{{ZVAL_BOOL, {{.bool_val = {'true' if value else 'false'}}}}}"
    elif zval_type == 2:  # INT
        value = struct.unpack('<q', file.read(8))[0]
        return f"{{ZVAL_INT, {{.int_val = {value}LL}}}}"
    elif zval_type == 3:  # FLOAT
        value = struct.unpack('<d', file.read(8))[0]
        return f"{{ZVAL_FLOAT, {{.float_val = {value}}}}}"
    elif zval_type == 4:  # STRING
        str_len = struct.unpack('<I', file.read(4))[0]
        str_data = file.read(str_len)
        # Escape the string for C
        escaped_str = str_data.decode('utf-8', errors='replace').replace('\\', '\\\\').replace('"', '\\"')
        return f"{{ZVAL_STRING, {{.string_val = {{\"{escaped_str}\", {str_len}}}}}}}"
    elif zval_type == 5:  # ARRAY
        size = struct.unpack('<I', file.read(4))[0]
        capacity = struct.unpack('<I', file.read(4))[0]
        return f"{{ZVAL_ARRAY, {{.array_val = {{NULL, {size}, {capacity}}}}}}}"
    elif zval_type == 8:  # RESOURCE
        ptr_type = struct.unpack('<I', file.read(4))[0]
        return f"{{ZVAL_RESOURCE, {{.resource_val = {{NULL, {ptr_type}}}}}}}"
    else:  # NULL or other types
        return "{ZVAL_NULL, {0}}"

def read_instruction(file):
    """Read an instruction from the file."""
    opcode = struct.unpack('<H', file.read(2))[0]
    operand1 = struct.unpack('<H', file.read(2))[0]
    operand2 = struct.unpack('<H', file.read(2))[0]
    
    return f"{{{opcode}, {operand1}, {operand2}}}"

def read_function(file):
    """Read a function from the file."""
    name_len = struct.unpack('<I', file.read(4))[0]
    name = file.read(name_len).decode('utf-8', errors='replace')
    
    code_size = struct.unpack('<I', file.read(4))[0]
    local_count = struct.unpack('<I', file.read(4))[0]
    param_count = struct.unpack('<I', file.read(4))[0]
    
    # Read instructions
    instructions = []
    for _ in range(code_size):
        instructions.append(read_instruction(file))
    
    return {
        'name': name,
        'code_size': code_size,
        'local_count': local_count,
        'param_count': param_count,
        'instructions': instructions
    }

def generate_c_source(mbc_file, output_file=None):
    """Generate C source code from MBC file."""
    try:
        with open(mbc_file, 'rb') as file:
            # Read header
            header = read_mbc_header(file)
            
            # Read constants
            constants = []
            for i in range(header['constant_count']):
                constants.append(read_zval(file))
            
            # Read functions
            functions = []
            for i in range(header['function_count']):
                functions.append(read_function(file))
            
            # Generate C source
            c_source = f"""// Auto-generated by micro-PHP objgen
// Source: {mbc_file}
// Generated on: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

#include "microphp.h"

// Constants
static const zval_t embedded_constants[] = {{
{chr(10).join(f"    {const}," for const in constants) if constants else "    {ZVAL_NULL, {0}},"}
}};

// Function code arrays
"""
            
            # Generate function code arrays
            for i, func in enumerate(functions):
                c_source += f"""static const instruction_t function_{i}_code[] = {{
{chr(10).join(f"    {instr}," for instr in func['instructions'])}
}};

"""
            
            # Generate function definitions
            c_source += """// Function definitions
static const function_t embedded_functions[] = {
"""
            
            for i, func in enumerate(functions):
                c_source += f"""    {{
        .name = "{func['name']}",
        .name_len = {func['name_len']},
        .code = (instruction_t*)function_{i}_code,
        .code_size = {func['code_size']},
        .local_count = {func['local_count']},
        .param_count = {func['param_count']}
    }},
"""
            
            c_source += """};

// Main bytecode structure
const bytecode_t embedded_program = {
    .magic = "MBC\\0",
    .version = 1,
    .constant_count = """ + str(header['constant_count']) + """,
    .constants = (zval_t*)embedded_constants,
    .function_count = """ + str(header['function_count']) + """,
    .functions = (function_t*)embedded_functions,
    .main_offset = """ + str(header['main_offset']) + """
};

// Function to get the embedded program
const bytecode_t* get_embedded_program(void) {
    return &embedded_program;
}
"""
            
            # Write output
            if output_file:
                with open(output_file, 'w') as out_file:
                    out_file.write(c_source)
                print(f"Generated C source: {output_file}")
            else:
                print(c_source)
            
            return 0
            
    except FileNotFoundError:
        print(f"Error: File '{mbc_file}' not found.")
        return 1
    except Exception as e:
        print(f"Error processing MBC file: {e}")
        return 1

def main():
    parser = argparse.ArgumentParser(
        description='Generate C source code from micro-PHP bytecode (.mbc) files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s script.mbc                    # Output to stdout
  %(prog)s script.mbc -o embedded.c      # Output to file
  %(prog)s -o embedded.c < script.mbc    # Read from stdin
        """
    )
    
    parser.add_argument('input', nargs='?', help='Input MBC file (or stdin if not specified)')
    parser.add_argument('-o', '--output', help='Output C file (default: stdout)')
    
    args = parser.parse_args()
    
    if args.input:
        # Read from file
        exit_code = generate_c_source(args.input, args.output)
    else:
        # Read from stdin
        if args.output:
            # Read stdin and write to file
            try:
                with open(args.output, 'w') as out_file:
                    # This is a simplified version - in practice you'd need to
                    # handle the binary MBC data from stdin properly
                    print("Error: Reading MBC from stdin not yet implemented")
                    exit_code = 1
            except Exception as e:
                print(f"Error writing to output file: {e}")
                exit_code = 1
        else:
            print("Error: No input file specified and no output file for stdin")
            exit_code = 1
    
    sys.exit(exit_code)

if __name__ == '__main__':
    main()
