#!/usr/bin/env python3
"""
micro-PHP Bytecode Inspector (mbc-inspect)

This tool allows you to examine the contents of .mbc files
generated by the micro-PHP compiler.
"""

import sys
import struct
import argparse
from pathlib import Path

# MBC file format constants
MBC_MAGIC = b'MBC\0'
MBC_VERSION = 1

# Zval types
ZVAL_TYPES = {
    0: 'NULL',
    1: 'BOOL',
    2: 'INT',
    3: 'FLOAT',
    4: 'STRING',
    5: 'ARRAY',
    6: 'OBJECT',
    7: 'CLOSURE',
    8: 'RESOURCE'
}

# Opcode types
OPCODE_TYPES = {
    0: 'NOP',
    1: 'CONST',
    2: 'ADD',
    3: 'SUB',
    4: 'MUL',
    5: 'DIV',
    6: 'MOD',
    7: 'ASSIGN',
    8: 'ASSIGN_ADD',
    9: 'ASSIGN_SUB',
    10: 'ASSIGN_MUL',
    11: 'ASSIGN_DIV',
    12: 'ASSIGN_MOD',
    13: 'INC',
    14: 'DEC',
    15: 'EQ',
    16: 'NEQ',
    17: 'LT',
    18: 'LTE',
    19: 'GT',
    20: 'GTE',
    21: 'AND',
    22: 'OR',
    23: 'NOT',
    24: 'JMP',
    25: 'JMPZ',
    26: 'JMPNZ',
    27: 'CALL',
    28: 'RETURN',
    29: 'POP',
    30: 'DUP',
    31: 'SWAP',
    32: 'GET_LOCAL',
    33: 'SET_LOCAL',
    34: 'GET_GLOBAL',
    35: 'SET_GLOBAL',
    36: 'NEW_ARRAY',
    37: 'ARRAY_GET',
    38: 'ARRAY_SET',
    39: 'STRING_CONCAT',
    40: 'CAST_INT',
    41: 'CAST_FLOAT',
    42: 'CAST_STRING',
    43: 'CAST_BOOL'
}

def read_mbc_header(file):
    """Read and validate MBC file header."""
    magic = file.read(4)
    if magic != MBC_MAGIC:
        raise ValueError(f"Invalid MBC magic: {magic}")
    
    version = struct.unpack('<I', file.read(4))[0]
    if version != MBC_VERSION:
        raise ValueError(f"Unsupported MBC version: {version}")
    
    constant_count = struct.unpack('<I', file.read(4))[0]
    function_count = struct.unpack('<I', file.read(4))[0]
    main_offset = struct.unpack('<I', file.read(4))[0]
    
    return {
        'version': version,
        'constant_count': constant_count,
        'function_count': function_count,
        'main_offset': main_offset
    }

def read_zval(file):
    """Read a zval from the file."""
    zval_type = struct.unpack('<B', file.read(1))[0]
    
    if zval_type not in ZVAL_TYPES:
        raise ValueError(f"Unknown zval type: {zval_type}")
    
    zval_info = {'type': ZVAL_TYPES[zval_type]}
    
    if zval_type == 1:  # BOOL
        zval_info['value'] = struct.unpack('<B', file.read(1))[0] != 0
    elif zval_type == 2:  # INT
        zval_info['value'] = struct.unpack('<q', file.read(8))[0]
    elif zval_type == 3:  # FLOAT
        zval_info['value'] = struct.unpack('<d', file.read(8))[0]
    elif zval_type == 4:  # STRING
        str_len = struct.unpack('<I', file.read(4))[0]
        zval_info['value'] = file.read(str_len).decode('utf-8', errors='replace')
    elif zval_type == 5:  # ARRAY
        size = struct.unpack('<I', file.read(4))[0]
        capacity = struct.unpack('<I', file.read(4))[0]
        zval_info['size'] = size
        zval_info['capacity'] = capacity
    elif zval_type == 8:  # RESOURCE
        ptr_type = struct.unpack('<I', file.read(4))[0]
        zval_info['resource_type'] = ptr_type
    
    return zval_info

def read_instruction(file):
    """Read an instruction from the file."""
    opcode = struct.unpack('<H', file.read(2))[0]
    operand1 = struct.unpack('<H', file.read(2))[0]
    operand2 = struct.unpack('<H', file.read(2))[0]
    
    opcode_name = OPCODE_TYPES.get(opcode, f'UNKNOWN_{opcode}')
    
    return {
        'opcode': opcode_name,
        'operand1': operand1,
        'operand2': operand2
    }

def read_function(file):
    """Read a function from the file."""
    name_len = struct.unpack('<I', file.read(4))[0]
    name = file.read(name_len).decode('utf-8', errors='replace')
    
    code_size = struct.unpack('<I', file.read(4))[0]
    local_count = struct.unpack('<I', file.read(4))[0]
    param_count = struct.unpack('<I', file.read(4))[0]
    
    # Read instructions
    instructions = []
    for _ in range(code_size):
        instructions.append(read_instruction(file))
    
    return {
        'name': name,
        'code_size': code_size,
        'local_count': local_count,
        'param_count': param_count,
        'instructions': instructions
    }

def inspect_mbc_file(filepath):
    """Inspect an MBC file and display its contents."""
    try:
        with open(filepath, 'rb') as file:
            print(f"=== micro-PHP Bytecode Inspector ===")
            print(f"File: {filepath}")
            print()
            
            # Read header
            header = read_mbc_header(file)
            print("Header:")
            print(f"  Version: {header['version']}")
            print(f"  Constants: {header['constant_count']}")
            print(f"  Functions: {header['function_count']}")
            print(f"  Main function offset: {header['main_offset']}")
            print()
            
            # Read constants
            if header['constant_count'] > 0:
                print("Constants:")
                for i in range(header['constant_count']):
                    try:
                        zval = read_zval(file)
                        print(f"  [{i}] {zval['type']}: {zval.get('value', 'N/A')}")
                    except Exception as e:
                        print(f"  [{i}] Error reading constant: {e}")
                print()
            
            # Read functions
            if header['function_count'] > 0:
                print("Functions:")
                for i in range(header['function_count']):
                    try:
                        func = read_function(file)
                        print(f"  [{i}] {func['name']}")
                        print(f"      Code size: {func['code_size']}")
                        print(f"      Locals: {func['local_count']}")
                        print(f"      Parameters: {func['param_count']}")
                        
                        if func['instructions']:
                            print("      Instructions:")
                            for j, instr in enumerate(func['instructions']):
                                print(f"        [{j}] {instr['opcode']} {instr['operand1']} {instr['operand2']}")
                        print()
                    except Exception as e:
                        print(f"  [{i}] Error reading function: {e}")
                        print()
            
            print("=== End of file ===")
            
    except FileNotFoundError:
        print(f"Error: File '{filepath}' not found.")
        return 1
    except Exception as e:
        print(f"Error reading MBC file: {e}")
        return 1
    
    return 0

def main():
    parser = argparse.ArgumentParser(
        description='Inspect micro-PHP bytecode (.mbc) files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s script.mbc                    # Basic inspection
  %(prog)s -v script.mbc                 # Verbose output
  %(prog)s *.mbc                         # Inspect all .mbc files
        """
    )
    
    parser.add_argument('files', nargs='+', help='MBC file(s) to inspect')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    exit_code = 0
    
    for filepath in args.files:
        path = Path(filepath)
        
        if not path.exists():
            print(f"Error: File '{filepath}' not found.")
            exit_code = 1
            continue
        
        if path.suffix.lower() != '.mbc':
            print(f"Warning: File '{filepath}' doesn't have .mbc extension.")
        
        if args.verbose:
            print(f"\n{'='*60}")
        
        result = inspect_mbc_file(filepath)
        if result != 0:
            exit_code = result
    
    sys.exit(exit_code)

if __name__ == '__main__':
    main()
